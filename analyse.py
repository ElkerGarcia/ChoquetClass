# -*- coding: utf-8 -*-
"""analyse.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18H0hix0s9iqX9WAELQrPKAKQcqhTrjw1
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from collections import Counter
from itertools import product
from collections import defaultdict
import random


def es_numero_o_valor(val):
    try:
        float(val)
        return True
    except:
        return False

def analise(dataset):
    # Leer primeras 5 filas como texto
    with open(dataset, 'r') as f:
        lineas_crudas = [line.strip().split(',') for _, line in zip(range(5), f)]

    # Evaluar si hay encabezado analizando la primera fila
    primera_fila = lineas_crudas[0]
    num_numericos = sum(es_numero_o_valor(x) for x in primera_fila)
    total = len(primera_fila)
    tiene_encabezado = num_numericos < total - 1  # permitimos 1 no numérico (como la clase)

    print(f"\n📌 ¿Tiene encabezado? {'Sí' if tiene_encabezado else 'No'}")

    # Mostrar las primeras 5 filas crudas para que el usuario decida
    print("\n🔍 Primeras 5 filas del archivo:")
    for fila in lineas_crudas:
        print(fila)

    # Leer con o sin encabezado
    if tiene_encabezado:
        df = pd.read_csv(dataset)
    else:
        df = pd.read_csv(dataset, header=None)

    # Pedir al usuario el índice de la columna que es la clase
    indice_clase = int(input("\n👉 Ingresa el índice de la columna que representa la CLASE: "))

    # Renombrar columnas a: atributo1, atributo2, ..., class
    nuevos_nombres = []
    for i in range(len(df.columns)):
        if i == indice_clase:
            nuevos_nombres.append("class")
        else:
            nuevos_nombres.append(f"atributo{i+1}")

    df.columns = nuevos_nombres

    print("\n✅ Nuevos encabezados:")
    print(df.columns.tolist())

    return df


#Calculamos los conjuntos de prueba y entrenamiento además calculamos los valores minimo y maximode cada columna



Values = {}

def preparacion(data_frame):
    # Mostrar columnas disponibles
    print("Columnas disponibles en el DataFrame:")
    print(data_frame.columns.tolist())

    # Pedir nombre de la clase
    class_column = input("\n📝 Ingresa el nombre de la columna objetivo (clase): ").strip()

    # Verificar si la columna existe
    if class_column not in data_frame.columns:
        raise ValueError(f"❌ La columna '{class_column}' no existe en el DataFrame.")

    # Eliminar filas con valores nulos (opcional)
    data_frame = data_frame.dropna()

    # Inicializar diccionario para min/max
    Values = {}

    # Dividir en entrenamiento y prueba
    train_Data, test_Data = train_test_split(
        data_frame,
        test_size=0.3,
        random_state=42,
        stratify=data_frame[class_column]
    )

    print("\n📊 DATA DE ENTRENAMIENTO (primeras filas):")
    print(train_Data.head())

    for atributo in train_Data.columns:
        if atributo != class_column:  # Evitar aplicar min/max a la clase
            min_val = train_Data[atributo].min()
            max_val = train_Data[atributo].max()
            Values[atributo] = [min_val, max_val]

    print("\n✅ Valores Mínimos y Máximos por atributo (sin incluir la clase):")
    for atributo, (min_val, max_val) in Values.items():
        print(f"{atributo}: min={min_val}, max={max_val}")

    return train_Data, test_Data, class_column, Values