# -*- coding: utf-8 -*-
"""Variables_Linguisticas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xNFMHwT694JkosjFqfXF0wjOCNUikxSP
"""
from .conjuntos_fuzzy import FuzzySet, MF_object, Triangular_MF, SingletonsSet
from numpy import array, linspace, meshgrid, geomspace, log10, finfo, float64
from scipy.interpolate import interp1d
from copy import deepcopy
from collections import defaultdict, OrderedDict
import re
import string
from math import prod
try:
    from matplotlib.pyplot import figure, axes, plot, show, title, subplots, legend, colorbar
    matplotlib = True
except ImportError:
    matplotlib = False
try:
    import seaborn as sns
except:
    pass

# constant values
linestyles= ["-", "--", ":", "-."]

# for sanitization
valid_characters = string.ascii_letters + string.digits + "()_ "

# constants for templating system
TEMPLATES_ENGAGED = 0
TEMPLATES_DISENGAGED = 1
TEMPLATES_MISSING_INFO = 2

class UndefinedUniverseOfDiscourseError(Exception):

    def __init__(self, message):
        self.message = message


class LinguisticVariable(object):
    """
        Creates a new linguistic variable.

        Args:
            FS_list: a list of FuzzySet instances.
            concept: a string providing a brief description of the concept represented by the linguistic variable (optional).
            universe_of_discourse: a list of two elements, specifying min and max of the universe of discourse. Optional, but it must be specified to exploit plotting facilities.
    """

    def __init__(self, FS_list=[], concept=None, universe_of_discourse=None):

        if FS_list==[]:
            raise Exception("ERROR: please specify at least one fuzzy set")
        self._universe_of_discourse = universe_of_discourse
        self._FSlist = FS_list
        self._concept = concept


    def get_values(self, v):
        result = {}
        for fs in self._FSlist:
            result[fs._term] = fs.get_value(v)
        return result


    def get_index(self, term):
        for n, fs in enumerate(self._FSlist):
            if fs._term == term: return n
        return -1


    def get_universe_of_discourse(self):
        """
        This method provides the leftmost and rightmost values of the universe of discourse of the linguistic variable.

        Returns:
            the two extreme values of the universe of discourse.
        """
        if self._universe_of_discourse is not None:
            return self._universe_of_discourse
        mins = []
        maxs = []
        try:
            for fs in self._FSlist:
                mins.append(min(fs._points.T[0]))
                maxs.append(max(fs._points.T[0]))
        except AttributeError:
            raise UndefinedUniverseOfDiscourseError("Cannot get the universe of discourse. Please, use point-based fuzzy sets or explicitly specify a universe of discourse")
        return min(mins), max(maxs)


    def draw(self, ax, TGT=None, element=None, highlight=None, xscale="linear"):
        """
        This method returns a matplotlib ax, representing all fuzzy sets contained in the liguistic variable.

        Args:
            ax: the matplotlib axis to plot to.
            TGT: (deprecated) show the memberships of a specific element of discourse TGT in the figure.
            element: show the memberships of a specific element of discourse in the figure.
            highlight: string, indicating the linguistic term/fuzzy set to highlight in the plot.
            xscale: default "linear", supported scales "log". Changes the scale of the xaxis.
        Returns:
            A matplotlib axis, representing all fuzzy sets contained in the liguistic variable.
        """
        if matplotlib == False:
            raise Exception("ERROR: please, install matplotlib for plotting facilities")
        if TGT is not None:
            print("Warning: argument 'TGT' is deprecated and will be discontinued in future relseases. Please use 'element'")
            element = TGT

        mi, ma = self.get_universe_of_discourse()
        if xscale == "linear":
            x = linspace(mi, ma, 10000)
        elif xscale == "log":
            if mi < 0 and ma > 0:
                x = geomspace(mi, -finfo(float64).eps, 5000) + geomspace(finfo(float64).eps, ma, 5000)
                # raise Exception("ERROR: cannot plot in log scale with negative universe of discourse")
            elif mi == 0:
                x = geomspace(finfo(float64).eps, ma, 10000)
            else:
                x = geomspace(mi, ma, 10000)
        else:
            raise Exception("ERROR: scale "+xscale+" not supported.")


        if highlight is None:
            linestyles= ["-", "--", ":", "-."]
        else:
            linestyles= ["-"]*4

        if element is not None:
            ax.plot([element, element], [0.0, 1], color="red", linestyle="--", linewidth=2.0, label="Value")


        for nn, fs in enumerate(self._FSlist):

            # singleton
            if isinstance(fs, SingletonsSet):
                xs = [pair[0] for pair in fs._funpointer._pairs]
                ys = [pair[1] for pair in fs._funpointer._pairs]
                ax.vlines(x=xs, ymin=0.0, ymax=ys, linestyles=linestyles[nn%4], color=ax._get_lines.get_next_color(), label=fs._term)


            elif fs._type == "function":
                y = [fs.get_value(xx) for xx in x]
                color = ax._get_lines.get_next_color()
                lw = 1

                if highlight==fs._term:
                    color="red"
                    lw =5
                elif highlight is not None:
                    color="lightgray"
                ax.plot(x,y, linestyles[nn%4], lw=lw, label=fs._term, color=color)

                # plot the membership degree on the fuzzy set
                if element is not None:
                    top = fs.get_value(element)
                    cut_y = [min(top, yy) for yy in y]
                    ax.fill([x[0]]+list(x)+[x[-1]],[0]+cut_y+[0] ,  color=color, alpha=0.5,)


            else:
                sns.regplot(x=fs._points.T[0], y=fs._points.T[1], marker="d", color="red", fit_reg=False, ax=ax)
                f = interp1d(fs._points.T[0], fs._points.T[1], bounds_error=False, fill_value=(fs.boundary_values[0], fs.boundary_values[1]))
                ax.plot(x, f(x), linestyles[nn%4], label=fs._term,)


        ax.set_xlabel(self._concept)
        ax.set_ylabel("Membership degree")
        ax.set_ylim(bottom=-0.05, top=1.05)
        if xscale == "log":
            ax.set_xscale("symlog", linthresh=10e-2)
            ax.set_xlim(x[0], x[-1])
        if highlight is None: ax.legend(loc="best")
        return ax


    def plot(self, outputfile="", TGT=None, element=None, highlight=None, xscale="linear"):
        """
        Shows a plot representing all fuzzy sets contained in the liguistic variable.

        Args:
            outputfile: path and filename where the plot must be saved.
            TGT: (deprecated) show the memberships of a specific element of discourse TGT in the figure.
            element: show the memberships of a specific element of discourse in the figure.
            highlight: string, indicating the linguistic term/fuzzy set to highlight in the plot.
            xscale: default "linear", supported scales "log". Changes the scale of the xaxis.
        """
        if matplotlib == False:
            raise Exception("ERROR: please, install matplotlib for plotting facilities")
        if TGT is not None:
            print("Warning: argument 'TGT' is deprecated and will be discontinued in future relseases. Please use 'element'")
            element = TGT

        fig, ax = subplots(1,1)
        self.draw(ax=ax, element=element, highlight=highlight, xscale=xscale)

        if outputfile != "":
            fig.savefig(outputfile)

        show()



    def __repr__(self):
        if self._concept is None:
            text = "N/A"
        else:
            text = self._concept
        return "<Linguistic variable '"+text+"', contains fuzzy sets %s, universe of discourse: %s>" % (str(self._FSlist), str(self._universe_of_discourse))