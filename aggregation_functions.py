# -*- coding: utf-8 -*-
"""aggregation_functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZmjqGRZq821vaU5rQ48Ya_1YEtJKMt7q
"""

import numpy as np

class CopulaChoquetExponential:
    """
    Implementación de la cópula tipo Choquet CC_mM con medida difusa
    de tipo Exponential Cardinality, permitiendo q como vector o diccionario.
    """

    def __init__(self, q_vector):
        """
        Parámetros:
        -----------
        q_vector : dict | list | np.array
            - Si es dict: {'Iris-setosa': 1.0, 'Iris-versicolor': 0.8, ...}
            - Si es list/array: [1.0, 1.0, 1.0] (orden correspondiente a las clases detectadas)
        """
        self.q_vector = q_vector

    def exponential_cardinality(self, subset_size, n, q):
        """ Calcula la medida difusa exponential cardinality: (|A|/n)^q """
        return (subset_size / n) ** q


    def choquet_copula(self, x, q):
        """ Calcula CC_mM(x) con medida exponential cardinality para un valor q dado. """
        x = np.array(x, dtype=float)
        n = len(x)
        if n == 0:
            return 0.0
        
        # Ordenar de menor a mayor
        x_sorted = np.sort(x)
        x_prev = 0.0
        result = 0.0

        for i in range(n):
            subset_size = n - i
            m_A = self.exponential_cardinality(subset_size, n, q)
            term = min(x_sorted[i], m_A) - min(x_prev, m_A)
            result += term
            x_prev = x_sorted[i]
        return result

    def calcular_por_clase(self, grados_asociacion):
        """
        Calcula la cópula Choquet CC_mM(x) para cada clase según su q correspondiente.

        Parámetro:
        -----------
        grados_asociacion : list[dict]
            Lista de diccionarios con los grados de asociación por clase.
            Ejemplo: [{'Iris-setosa': 0.1}, {'Iris-versicolor': 0.2}, ...]

        Retorna:
        --------
        dict : {'Iris-setosa': valor, 'Iris-versicolor': valor, ...}
        """
        # Detectar clases
        clases = sorted({k for d in grados_asociacion for k in d.keys()})
        resultados = {}

        # Si q_vector es lista, convertirla a diccionario usando el orden de las clases
        if isinstance(self.q_vector, (list, np.ndarray)):
            if len(self.q_vector) != len(clases):
                raise ValueError(f"El vector q debe tener {len(clases)} elementos (uno por clase).")
            q_dict = {clase: q for clase, q in zip(clases, self.q_vector)}
        elif isinstance(self.q_vector, dict):
            q_dict = self.q_vector
        else:
            raise TypeError("q_vector debe ser dict, list o numpy array")

        # Calcular por clase
        for clase in clases:
            x_vals = [d.get(clase, 0.0) for d in grados_asociacion]
            q = q_dict.get(clase, 1.0)
            resultados[clase] = self.choquet_copula(x_vals, q)

        return resultados






class CF1F2_Integral:
    """
    Implementación de la función de agregación C(F1,F2)_m
    con medida difusa tipo exponential cardinality.
    """

    def __init__(self, q_vector):
        """
        Parámetro:
        -----------
        q_vector : dict | list | np.array
            - Si es dict: {'Iris-setosa': 1.0, 'Iris-versicolor': 0.8, ...}
            - Si es list/array: [1.0, 1.0, 1.0]
        """
        self.q_vector = q_vector

    # ---- F1 y F2 ----
    def F1(self, x, y):
        return np.sqrt(x * y)

    def F2(self, x, y):
        return x * (y ** 2)

    # ---- Medida difusa exponential cardinality ----
    def exponential_cardinality(self, subset_size, n, q):
        return (subset_size / n) ** q

    # ---- Integral CF1F2 para un vector x y parámetro q ----
    def compute(self, x, q):
        x = np.array(x, dtype=float)
        n = len(x)
        if n == 0:
            return 0.0

        # Orden ascendente
        x_sorted = np.sort(x)
        x_prev = 0.0
        total = x_sorted[0]  # primer término especial

        for i in range(1, n):
            subset_size = n - i
            m_A = self.exponential_cardinality(subset_size, n, q)

            term = self.F1(x_sorted[i], m_A) - self.F2(x_sorted[i-1], m_A)
            total += term

        # limitar a [0,1]
        return min(1.0, total)

    # ---- Calcular por clase ----
    def calcular_por_clase(self, grados_asociacion):
        """
        grados_asociacion: lista de dicts con grados de asociación por clase
        Ejemplo: [{'Iris-setosa': 0.1}, {'Iris-versicolor': 0.2}, ...]
        """
        clases = sorted({k for d in grados_asociacion for k in d.keys()})
        resultados = {}

        # adaptar q_vector si es lista
        if isinstance(self.q_vector, (list, np.ndarray)):
            if len(self.q_vector) != len(clases):
                raise ValueError(f"El vector q debe tener {len(clases)} elementos (uno por clase).")
            q_dict = {clase: q for clase, q in zip(clases, self.q_vector)}
        elif isinstance(self.q_vector, dict):
            q_dict = self.q_vector
        else:
            raise TypeError("q_vector debe ser dict, list o numpy array")

        for clase in clases:
            x_vals = [d.get(clase, 0.0) for d in grados_asociacion]
            q = q_dict.get(clase, 1.0)
            resultados[clase] = self.compute(x_vals, q)

        return resultados






class WinningRuleClassifier:
    """
    Implementación del método Winning Rule (WR):
    Para cada clase, se considera únicamente la regla que tenga
    la máxima compatibilidad (grado de asociación) con el ejemplo.

    Fórmula:
    SClass_j(e_b) = max_i { AClass^i_j(e_b) }
    """

    def __init__(self):
        pass


    def calcular_puntajes(self, grados_asociacion):
        """
        Calcula el puntaje WR por clase a partir de los grados de asociación.

        Parámetro:
        -----------
        grados_asociacion : list[dict]
            Lista de diccionarios con los grados de asociación por clase.
            Ejemplo:
                [
                    {'Iris-setosa': 0.2, 'Iris-versicolor': 0.1, 'Iris-virginica': 0.0},
                    {'Iris-setosa': 0.5, 'Iris-versicolor': 0.6, 'Iris-virginica': 0.3},
                    ...
                ]

        Retorna:
        --------
        dict : {'Iris-setosa': valor, 'Iris-versicolor': valor, 'Iris-virginica': valor}
            Valor máximo de compatibilidad por clase.
        """
        # Identificar todas las clases disponibles
        clases = set()
        for d in grados_asociacion:
            clases.update(d.keys())

        resultados = {}

        # Para cada clase, tomar el máximo grado de asociación
        for clase in clases:
            maximo = max(d.get(clase, 0.0) for d in grados_asociacion)
            resultados[clase] = maximo

        return resultados





class AdditiveCombinationClassifier:
    """
    Implementación del método Additive Combination (AC) para sistemas de clasificación difusa.

    Este método agrega todas las reglas activadas (fired rules) por clase usando la suma normalizada:
    
        SClass_j(e_b) = (Σ_i AClass^i_j(e_b)) / max_j Σ_i AClass^i_j(e_b)
    """

    @staticmethod
    def calcular_puntajes(grados_asociacion):
        """
        Calcula los puntajes normalizados por clase usando la combinación aditiva.

        Parámetro:
        -----------
        grados_asociacion : list[dict]
            Lista de diccionarios que contienen los grados de asociación de cada regla con las clases.
            Ejemplo:
            [
                {'Iris-setosa': 0.2, 'Iris-versicolor': 0.1, 'Iris-virginica': 0.0},
                {'Iris-setosa': 0.4, 'Iris-versicolor': 0.3, 'Iris-virginica': 0.1},
                ...
            ]

        Retorna:
        --------
        dict : {'Iris-setosa': valor, 'Iris-versicolor': valor, ...}
            Puntajes normalizados por clase.
        """
        # Identificar todas las clases
        clases = set()
        for d in grados_asociacion:
            clases.update(d.keys())

        # Sumar los grados de asociación por clase
        suma_por_clase = {clase: 0.0 for clase in clases}
        for d in grados_asociacion:
            for clase, valor in d.items():
                suma_por_clase[clase] += float(valor)

        # Normalizar dividiendo entre el máximo total
        max_total = max(suma_por_clase.values()) if suma_por_clase else 1.0
        puntajes_normalizados = {
            clase: valor / max_total if max_total > 0 else 0.0
            for clase, valor in suma_por_clase.items()
        }

        return puntajes_normalizados



